AWSTemplateFormatVersion: 2010-09-09
Description: AWS CloudFormation Kestra Lab EC2 standalone template

Parameters:
  Name:
    Type: String
    Default: KestraLab

  CreateNetwork:
    Type: String
    AllowedValues:
      - "true"
      - "false"   

  ExistingSubnetId:
    Type: String
    Default: ""
  ExistingVpcId:
    Type: String
    Default: ""

  SshTunnelUser:
    Type: String
    Default: ""
  SshTunnelPassword:
    Type: String
    Default: ""
    NoEcho: true

  EbsVolumeId1:
    Type: String
    Default: ""
    Description: EBS Volume for Kestra storage

  EbsVolumeId2:
    Type: String
    Default: ""
    Description: EBS Volume for Postgres storage

  TagKey:
    Type: String
    Default: ""
  TagValue:
    Type: String
    Default: ""

  KestraImage:
    Type: String
    Default: kestra/kestra:latest-full    
  KestraImageRepositoryUser:
    Type: String
    Default: ""
  KestraImageRepositoryPassword:
    Type: String
    Default: ""
    NoEcho: true

  PostgresUser:
    Type: String
    Default: kestra
  PostgresPassword:
    Type: String
    NoEcho: true

  VaultToken:
    Type: String
    NoEcho: true

Conditions:
  ShouldCreateNetwork: !Equals [ !Ref CreateNetwork, "true" ]

  ShouldCreateSshTunnel: !And
    - !Not [ !Equals [ !Ref SshTunnelUser, "" ] ]
    - !Not [ !Equals [ !Ref SshTunnelPassword, "" ] ]

  EbsVolumeId1Specified: !Not [ !Equals [ !Ref EbsVolumeId1, "" ] ]
  EbsVolumeId2Specified: !Not [ !Equals [ !Ref EbsVolumeId2, "" ] ]
  
  TagSpecified: !And 
    - !Not [ !Equals [ !Ref TagKey, "" ] ]
    - !Not [ !Equals [ !Ref TagValue, "" ] ]

  HasKestraImageRepositoryCredentials: !And
    - !Not [ !Equals [ !Ref KestraImageRepositoryUser, "" ] ]
    - !Not [ !Equals [ !Ref KestraImageRepositoryPassword, "" ] ]    

Resources:

  # Network

  VPC:
    Type: AWS::EC2::VPC
    Condition: ShouldCreateNetwork
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub ${Name}
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Condition: ShouldCreateNetwork
    Properties:
      Tags:
        - Key: Name
          Value: !Sub ${Name}
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]

  GatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Condition: ShouldCreateNetwork
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  RouteTable:
    Type: AWS::EC2::RouteTable
    Condition: ShouldCreateNetwork
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${Name}
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]

  InternetRoute:
    Type: AWS::EC2::Route
    Condition: ShouldCreateNetwork
    Properties:
      RouteTableId: !Ref RouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  SubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Condition: ShouldCreateNetwork
    Properties:
      SubnetId: !Ref SubnetA
      RouteTableId: !Ref RouteTable

  SubnetA:
    Type: AWS::EC2::Subnet
    Condition: ShouldCreateNetwork
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Sub ${AWS::Region}a
      Tags:
        - Key: Name
          Value: !Sub ${Name}-SubnetA
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]

  # Security Group

  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub ${Name}
      VpcId: !If [ ShouldCreateNetwork, !Ref VPC, !Ref ExistingVpcId ]
      Tags:
        - Key: Name
          Value: !Sub ${Name}
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]

  SecurityGroupIngressPostgres:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref SecurityGroup
      IpProtocol: tcp
      FromPort: 5432
      ToPort: 5432
      SourceSecurityGroupId: !Ref SecurityGroup

  SecurityGroupIngressHttp:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref SecurityGroup
      IpProtocol: tcp
      FromPort: 8080
      ToPort: 8081
      SourceSecurityGroupId: !If [ ShouldCreateSshTunnel, !Ref SecurityGroup, !Ref AWS::NoValue ]
      CidrIp: !If [ ShouldCreateSshTunnel, !Ref AWS::NoValue, 0.0.0.0/0 ]

  SecurityGroupIngressSshTunnel:
    Type: AWS::EC2::SecurityGroupIngress
    Condition: ShouldCreateSshTunnel
    Properties:
      GroupId: !Ref SecurityGroup
      IpProtocol: tcp
      FromPort: 2222
      ToPort: 2222
      CidrIp: 0.0.0.0/0                 

  # Cloud Map

  CloudMapNamespace:
    Type: AWS::ServiceDiscovery::PrivateDnsNamespace
    Properties:
      Name: !Sub ${Name}
      Vpc: !If [ ShouldCreateNetwork, !Ref VPC, !Ref ExistingVpcId ]
      Tags:
        - Key: Name
          Value: !Sub ${Name}
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]

  PostgresServiceDiscoveryService:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Name: !Sub ${Name}Postgres
      Description: Discover PostgreSQL service
      NamespaceId: 
        Ref: CloudMapNamespace
      DnsConfig:
        DnsRecords:
          - Type: A
            TTL: 60        
      HealthCheckCustomConfig:
        FailureThreshold: 1    
      Tags:
        - Key: Name
          Value: !Sub ${Name}Postgres
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]

  # EC2

  KestraEC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: t3.xlarge
      ImageId: '{{resolve:ssm:/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2}}'
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: 20
            VolumeType: gp3
            DeleteOnTermination: true
            Encrypted: false
      NetworkInterfaces:
        - AssociatePublicIpAddress: !If [ ShouldCreateNetwork, true, false ]
          DeviceIndex: 0
          GroupSet:
            - !Ref SecurityGroup
          SubnetId: !If [ ShouldCreateNetwork, !Ref SubnetA, !Ref ExistingSubnetId ]
      # KeyName: key pair name
      IamInstanceProfile: !Ref EC2InstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          # Install Docker
          amazon-linux-extras install docker -y
          service docker start
          systemctl enable docker

          # Create a Docker network
          docker network create ${Name}

          # Download and run the Vault image
          docker run -d --name ${Name}Vault \
            --network ${Name} \
            -e VAULT_DEV_ROOT_TOKEN_ID=${VaultToken} \
            -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
            --restart unless-stopped \
            --log-driver=awslogs \
            --log-opt awslogs-region=${AWS::Region} \
            --log-opt awslogs-group=${KestraEC2LogGroup} \
            hashicorp/vault:latest server -dev

          # Create a directory for Kestra storage
          KESTRA_STORAGE_PATH=/app/storage
          mkdir -p $KESTRA_STORAGE_PATH

          # Define the Kestra startup script
          read -r -d '' KESTRA_INIT_SCRIPT << EOF
          KESTRA_INIT_SCRIPT_PLACEHOLDER
          EOF

          # Mount the EBS volume for Kestra storage if present
          if [ ! -z "${EbsVolumeId1}" ]; then
            DEVICE=$(readlink -f /dev/sdf)
            MOUNT_POINT=$KESTRA_STORAGE_PATH
            FS_TYPE=$(file -s $DEVICE | cut -d' ' -f2)
            if [ "$FS_TYPE" == "data" ]; then
              mkfs -t ext4 $DEVICE
            else
              KESTRA_INIT_SCRIPT="./kestra-ee server standalone"
            fi
            mount $DEVICE $MOUNT_POINT
            echo "$DEVICE $MOUNT_POINT ext4 defaults,nofail 0 2" >> /etc/fstab
          fi

          # Check if credentials are present
          if [ "${KestraImageRepositoryUser}" != "" ] && [ "${KestraImageRepositoryPassword}" != "" ]; then
            registry=$(echo "${KestraImage}" | cut -d'/' -f1)
            if [[ $registry == *"."* ]]; then
              echo "${KestraImageRepositoryPassword}" | docker login $registry -u ${KestraImageRepositoryUser} --password-stdin
            else
              echo "${KestraImageRepositoryPassword}" | docker login -u ${KestraImageRepositoryUser} --password-stdin
            fi
          fi

          # Define Kestra configuration
          read -r -d '' KESTRA_CONFIGURATION << EOF
          KESTRA_CONFIGURATION_PLACEHOLDER
          EOF

          # Download and run the Kestra image
          docker run -d --name ${Name} \
            --network ${Name} \
            -e KESTRA_CONFIGURATION="$KESTRA_CONFIGURATION" \
            -v $KESTRA_STORAGE_PATH:/app/storage \
            -v /var/run/docker.sock:/var/run/docker.sock \
            --user=root \
            -p 8080:8080 \
            --restart unless-stopped \
            --log-driver=awslogs \
            --log-opt awslogs-region=${AWS::Region} \
            --log-opt awslogs-group=${KestraEC2LogGroup} \
            --entrypoint /bin/sh \
            ${KestraImage} \
            -c "$KESTRA_INIT_SCRIPT"
      Tags:
        - Key: Name
          Value: !Sub ${Name}
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]

  PostgresEC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: t3.large
      ImageId: '{{resolve:ssm:/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2}}'
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: 20
            VolumeType: gp3
            DeleteOnTermination: true
            Encrypted: false      
      NetworkInterfaces:
        - AssociatePublicIpAddress: !If [ ShouldCreateNetwork, true, false ]
          DeviceIndex: 0
          GroupSet:
            - !Ref SecurityGroup
          SubnetId: !If [ ShouldCreateNetwork, !Ref SubnetA, !Ref ExistingSubnetId ]
      # KeyName: key pair name
      IamInstanceProfile: !Ref EC2InstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          # Actualizar los paquetes del sistema y asegurar que AWS CLI esté instalado
          yum update -y
          yum install -y aws-cli

          # Install Docker
          amazon-linux-extras install docker -y
          service docker start
          systemctl enable docker

          # Create a directory for Postgres storage
          POSTGRES_DATA_PATH=/var/lib/postgresql/data
          mkdir -p $POSTGRES_DATA_PATH

          # Mount the EBS volume for Postgres storage if present
          if [ ! -z "${EbsVolumeId2}" ]; then
            DEVICE=$(readlink -f /dev/sdf)
            MOUNT_POINT=$POSTGRES_DATA_PATH
            FS_TYPE=$(file -s $DEVICE | cut -d' ' -f2)
            # If the volume is not formatted, format it and prepare it
            if [ "$FS_TYPE" == "data" ]; then
              mkfs -t ext4 $DEVICE
              mount $DEVICE $MOUNT_POINT
              rm -rf $MOUNT_POINT/lost+found
              chown 999:999 $MOUNT_POINT            
            else
              mount $DEVICE $MOUNT_POINT
            fi
            echo "$DEVICE $MOUNT_POINT ext4 defaults,nofail 0 2" >> /etc/fstab
          fi

          # Register the instance with the service discovery service
          aws servicediscovery register-instance --service-id ${PostgresServiceDiscoveryService} --instance-id $(curl http://169.254.169.254/latest/meta-data/instance-id) --attributes AWS_INSTANCE_IPV4=$(curl http://169.254.169.254/latest/meta-data/local-ipv4) --region ${AWS::Region}

          docker run -d --name ${Name}Postgres \
            -e POSTGRES_PASSWORD=${PostgresPassword} \
            -e POSTGRES_USER=${PostgresUser} \
            -e POSTGRES_DB=kestra \
            -v $POSTGRES_DATA_PATH:/var/lib/postgresql/data \
            -p 5432:5432 \
            --restart unless-stopped \
            --log-driver=awslogs \
            --log-opt awslogs-region=${AWS::Region} \
            --log-opt awslogs-group=${PostgresEC2LogGroup} \
            postgres:latest
      Tags:
        - Key: Name
          Value: !Sub ${Name}Postgres
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]

  SshEC2Instance:
    Type: AWS::EC2::Instance
    Condition: ShouldCreateSshTunnel
    Properties:
      InstanceType: t3.micro
      ImageId: '{{resolve:ssm:/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2}}'
      NetworkInterfaces:
        - AssociatePublicIpAddress: !If [ ShouldCreateNetwork, true, false ]
          DeviceIndex: 0
          GroupSet:
            - !Ref SecurityGroup
          SubnetId: !If [ ShouldCreateNetwork, !Ref SubnetA, !Ref ExistingSubnetId ]
      # KeyName: key pair name
      IamInstanceProfile: !Ref EC2InstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          # Install Docker
          amazon-linux-extras install docker -y
          systemctl start docker
          systemctl enable docker
          
          # Run Docker container for the SSH server
          docker run -d --name ${Name}Ssh \
            -e DOCKER_MODS=linuxserver/mods:openssh-server-ssh-tunnel \
            -e PUID=1000 \
            -e PGID=1000 \
            -e TZ=Etc/UTC \
            -e PASSWORD_ACCESS=true \
            -e USER_NAME=${SshTunnelUser} \
            -e USER_PASSWORD=${SshTunnelPassword} \
            -p 2222:2222 \
            --restart unless-stopped \
            --log-driver=awslogs \
            --log-opt awslogs-region=${AWS::Region} \
            --log-opt awslogs-group=${SshEC2LogGroup} \
            linuxserver/openssh-server:latest
      Tags:
        - Key: Name
          Value: !Sub ${Name}Ssh
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ] 

  # EBS Volumes attachment

  EbsVolumeAttachment1:
    Type: AWS::EC2::VolumeAttachment
    Condition: EbsVolumeId1Specified
    Properties:
      Device: /dev/sdf
      InstanceId: !Ref KestraEC2Instance
      VolumeId: !Ref EbsVolumeId1

  EbsVolumeAttachment2:
    Type: AWS::EC2::VolumeAttachment
    Condition: EbsVolumeId2Specified
    Properties:
      Device: /dev/sdf
      InstanceId: !Ref PostgresEC2Instance
      VolumeId: !Ref EbsVolumeId2

  # Logs
  
  KestraEC2LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /ec2/${Name}
      Tags:
        - Key: Name
          Value: !Sub ${Name}
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]
  
  PostgresEC2LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /ec2/${Name}Postgres
      Tags:
        - Key: Name
          Value: !Sub ${Name}Postgres
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]

  SshEC2LogGroup:
    Type: AWS::Logs::LogGroup
    Condition: ShouldCreateSshTunnel
    Properties:
      LogGroupName: !Sub /ec2/${Name}Ssh   
      Tags:
        - Key: Name
          Value: !Sub ${Name}Ssh
        - Key: !If [ TagSpecified, !Ref TagKey, !Ref AWS::NoValue ]
          Value: !If [ TagSpecified, !Ref TagValue, !Ref AWS::NoValue ]    

  # Roles and Policies

  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${Name}EC2Role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${Name}EC2ServiceDiscoveryPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - servicediscovery:*
                  - route53:CreateHealthCheck
                Resource: '*'
        - PolicyName: !Sub ${Name}EC2LogPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/ec2/${Name}*
        - PolicyName: !Sub ${Name}EC2SSMPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameters
                Resource: '*'
        - PolicyName: !Sub ${Name}EC2EBSVolumePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:AttachVolume
                  - ec2:DetachVolume
                  - ec2:DescribeVolumes
                Resource: '*'
  
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref EC2Role
